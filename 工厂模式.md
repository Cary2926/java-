# 工厂模式

## 实例

> 实现一个导出数据的应用框架，来让客户选择数据的导出方式，并真正执行数据导出。

### 1. 文件对象的接口
  
```java
/**
 * 导出的文件对象的接口
 */
public interface ExportFileApi {
   /**
    * 导出内容成为文件
    * @param data 示意：需要保存的数据
    * @return 是否导出成功
    */
   public boolean export(String data);
}
```

### 2. 文件对象的具体实现

``` java
/**
   * 导出成文本文件格式的对象
   */
public class ExportTxtFile implements ExportFileApi{
      public boolean export(String data) {
          //简单示意一下，这里需要操作文件
          System.out.println("导出数据"+data+"到文本文件");
          return true;
      }
}

/**
   * 导出成数据库备份文件形式的对象
   */
public class ExportDB implements ExportFileApi{
      public boolean export(String data) {
          //简单示意一下，这里需要操作数据库和文件
          System.out.println("导出数据"+data+"到数据库备份文件");
          return true;
      }
}
```

### 3. Creator的实现（工厂抽象类）

```java
/**
   * 实现导出数据的业务功能对象
   */
public abstract class ExportOperate {
      /**
       * 导出文件
       * @param data 需要保存的数据
       * @return 是否成功导出文件
       */
      public boolean export(String data){
          //使用工厂方法
          ExportFileApi api = factoryMethod();
          return api.export(data);
      }
      /**
       * 工厂方法，创建导出的文件对象的接口对象
       * @return 导出的文件对象的接口对象
       */
      protected abstract ExportFileApi factoryMethod();
}
```

### 客户端使用Creator对象时候的调用顺序示意图

![20231221164419](http://raw.githubusercontent.com/Cary2926/java-/main/note_image/20231221164419.png)

### 4. 具体creator类的实现

```java
/**
   * 实现导出数据的业务功能对象
   */
public abstract class ExportOperate {
      /**
       * 导出文件
       * @param data 需要保存的数据
       * @return 是否成功导出文件
       */
      public boolean export(String data){
          //使用工厂方法
          ExportFileApi api = factoryMethod();
          return api.export(data);
      }
      /**
       * 工厂方法，创建导出的文件对象的接口对象
       * @return 导出的文件对象的接口对象
       */
      protected abstract ExportFileApi factoryMethod();
}
```

### 5. 客户端调用

```java
public class Client {
      public static void main(String[] args) {
          //创建需要使用的Creator对象
          ExportOperate operate = new ExportDBOperate();
          //调用输出数据的功能方法
          operate.export("测试数据");
      }
}
```

## 使用场景

- **当一个类不知道它所需要的对象的类时**
    在工厂方法模式中，客户端不需要知道具体产品类的类名，只需要知道所对应的工厂即可；

- **当一个类希望通过其子类来指定创建对象时**
    在工厂方法模式中，对于抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象，利用面向对象的多态性和里氏代换原则，在程序运行时，子类对象将覆盖父类对象，从而使得系统更容易扩展。
- 将创建对象的任务委托给多个工厂子类中的某一个，客户端在使用时可以无须关心是哪一个工厂子类创建产品子类，需要时再动态指定，可将具体工厂类的类名存储在配置文件或数据库中。

## 本质

- 工厂方法模式的本质：延迟到子类来选择实现。
- 工厂方法本身并不会去实现产品接口，具体的产品实现是已经写好了的，工厂方法只要去选择实现就好了。

## 解决的问题

>需要创建具体实例对象，但是只知道接口类型，不知道具体实现。

采取**无为而治**的方式：不是需要接口对象吗，那就定义一个方法来创建；可是事实上它自己是不知道如何创建这个接口对象的，没有关系，那就定义成抽象方法就好了，自己实现不了，那就让子类来实现，这样这个对象本身就可以只是面向接口编程，而无需关心到底如何创建接口对象了。

工厂一旦需要生产新产品就需要修改工厂类的方法逻辑，违背了“开放 - 关闭原则

>1. 即简单工厂模式的缺点
>2. 之所以可以解决简单工厂的问题，是因为工厂方法模式把具体产品的创建推迟到工厂类的子类（具体工厂）中，此时工厂类不再负责所有产品的创建，而只是给出具体工厂必须实现的接口，这样工厂方法模式在添加新产品的时候就不修改工厂类逻辑而是添加新的工厂子类，符合开放封闭原则，克服了简单工厂模式中缺点


## 设计模式的原则

- 工厂方法模式很好的体现了“依赖倒置原则”。
  
依赖倒置原则告诉我们“要依赖抽象，不要依赖于具体类”，简单点说就是：不能让高层组件依赖于低层组件，而且不管高层组件还是低层组件，都应该依赖于抽象。
那么倒置的是什么呢？倒置的是这个接口的“**所有权**”。事实上，ExportFileApi接口中定义的功能，都是由高层组件ExportOperate来提出的要求，也就是说接口中的功能，是高层组件需要的功能。但是高层组件只是提出要求，并不关心如何实现，而低层组件，就是来真正实现高层组件所要求的接口功能的。因此看起来，低层实现的接口的所有权并不在底层组件手中，而是倒置到高层组件去了。

## 缺点

- 添加新产品时，除了增加新产品类外，还要提供与之对应的具体工厂类，系统类的个数将成对增加，在一定程度上增加了系统的复杂度；同时，有更多的类需要编译和运行，会给系统带来一些额外的开销；
- 由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度，且在实现时可能需要用到DOM、反射等技术，增加了系统的实现难度。
- 虽然保证了工厂方法内的对修改关闭，但对于使用工厂方法的类，如果要更换另外一种产品，仍然需要修改实例化的具体工厂类；
- 一个具体工厂只能创建一种具体产品

## 相关模式

### 1. 抽象工厂模式

### 2. 模板方法模式

这两个模式外观类似，都是有一个抽象类，然后由子类来提供一些实现，但是工厂方法模式的子类专注的是创建产品对象，而模板方法模式的子类专注的是为固定的算法骨架提供某些步骤的实现。

这两个模式可以组合使用，通常在模板方法模式里面，使用工厂方法来创建模板方法需要的对象。

## 开源架构中哪些使用这一模式

开源架构中有很多地方使用工厂模式来创建对象实例，特别是在需要灵活处理对象创建过程、降低耦合度以及提供统一的接口时。一些常见的开源架构中使用工厂模式的地方包括：

1. **Spring Framework**：Spring框架广泛使用工厂模式，例如通过`ApplicationContext`创建Bean实例。Spring的IoC容器利用工厂模式来管理Bean的生命周期和依赖注入。

2. **Hibernate ORM**：Hibernate使用工厂模式来创建`SessionFactory`实例，该实例用于管理数据库连接并创建`Session`对象，提供持久化操作的能力。

3. **Guava库**：Google的Guava库中也使用了工厂模式，比如`CacheBuilder`用于创建缓存实例，提供了一种灵活的方式来配置和构建缓存对象。

4. **JUnit测试框架**：在测试中，JUnit框架使用工厂模式来创建测试实例，允许开发者通过不同的方法创建测试对象并执行测试用例。

5. **Android开发**：在Android开发中，常常利用工厂模式来创建各种不同类型的对象，比如`LayoutInflater`用于创建布局资源，`Intent`的工厂方法用于创建意图对象等等。

这些开源框架和库都充分利用了工厂模式的优点，通过抽象工厂接口，将对象的创建与使用代码解耦，提高了代码的灵活性、可维护性和可测试性。
